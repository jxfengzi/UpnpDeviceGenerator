/* Automatic generated by DeviceToC */

#include "tiny_memory.h"
#include "tiny_log.h"
#include "BleGateway.h"

#define TAG             "BleGateway"

static const char * _ID_BleOperation = "urn:upnp-org:serviceId:BleOperation";

static TinyRet BleGateway_Construct(BleGateway *thiz, UpnpDevice *device, UpnpRuntime *runtime);
static void BleGateway_Dispose(BleGateway *thiz);

struct _BleGateway {
    UpnpDevice *device;
    UpnpRuntime *runtime;
    BleOperation *_BleOperation;
};

BleGateway * BleGateway_Create(UpnpDevice *device, UpnpRuntime *runtime) {
    BleGateway * thiz = NULL;

    RETURN_VAL_IF_FAIL(device, NULL);
    RETURN_VAL_IF_FAIL(runtime, NULL);

    do {
        thiz = (BleGateway *)tiny_malloc(sizeof(BleGateway));
        if (thiz == NULL) {
            LOG_E(TAG, "OUT OF MEMORY!");
            break;
        }

        if (RET_FAILED(BleGateway_Construct(thiz, device, runtime))) {
            LOG_E(TAG, "BleGateway_Construct failed");
            BleGateway_Delete(thiz);
            thiz = NULL;
            break;
        }
    } while (0);

    return thiz;
}

static TinyRet BleGateway_Construct(BleGateway *thiz, UpnpDevice *device, UpnpRuntime *runtime) {
    TinyRet ret = TINY_RET_OK;

    RETURN_VAL_IF_FAIL(thiz, TINY_RET_E_ARG_NULL);

    do {
        memset(thiz, 0, sizeof(BleGateway));
        thiz->device = device;
        thiz->runtime = runtime;

        if (!STR_EQUAL(BLEGATEWAY_DEVICE_TYPE, UpnpDevice_GetDeviceType(device))) {
            LOG_E(TAG, "DEVICE_TYPE invalid: %s", UpnpDevice_GetDeviceType(device));
            ret = TINY_RET_E_CONSTRUCT;
            break;
        }

        UpnpService * _BleOperation = NULL;

         _BleOperation = UpnpDevice_GetService(device, _ID_BleOperation);
        if (_BleOperation == NULL) {
            LOG_E(TAG, "Service not found: %s", _ID_BleOperation);
            ret = TINY_RET_E_CONSTRUCT;
            break;
        }

        thiz->_BleOperation = BleOperation_Create(_BleOperation, runtime);
        if (thiz->_BleOperation == NULL) {
            LOG_E(TAG, "BleOperation_Create: failed");
            ret = TINY_RET_E_CONSTRUCT;
            break;
        }
    } while (0);

    return ret;
}

static void BleGateway_Dispose(BleGateway *thiz) {
    RETURN_IF_FAIL(thiz);

    if (thiz->_BleOperation != NULL) {
        BleOperation_Delete(thiz->_BleOperation);
    }
}

void BleGateway_Delete(BleGateway *thiz) {
    RETURN_IF_FAIL(thiz);

    BleGateway_Dispose(thiz);
    tiny_free(thiz);
}

const char * BleGateway_GetDeviceType(BleGateway *thiz) {
    RETURN_VAL_IF_FAIL(thiz, NULL);

    return BLEGATEWAY_DEVICE_TYPE;
}

BleOperation * BleGateway_GetBleOperation(BleGateway *thiz) {
    RETURN_VAL_IF_FAIL(thiz, NULL);

    return thiz->_BleOperation;
}

